# Connect to Confluent Cloud
bootstrap.servers=pkc-n00kk.us-east-1.aws.confluent.cloud:9092
security.protocol=SASL_SSL
sasl.jaas.config=org.apache.kafka.common.security.plain.PlainLoginModule required username='IXRFA7BRHYS2U5A4' password='mH5fhaLQpFf0jvMEzjTCut3AgspDlW44wYn5da3JyODuOSGIhlQKM3FLQolauBz/';
sasl.mechanism=PLAIN

# Producer Properties

# The producer will attempt to batch records together into fewer requests whenever multiple records are being sent to the same partition.
# Requests sent to brokers will contain multiple batches, one for each partition with data available to be sent.
# Increase to 100000 - 200000 to optimize throughput (default 16384)
batch.size=100000

# Rather than immediately sending out a record, the producer will wait for up to the given delay to allow other records to be sent so that the sends can be batched together
# Increase to 10-100 to optimize throughput
# Set to 0 to reduce latency
linger.ms=100

# Compression requires more CPU cycles but reduces network bandwidth
# Valid values: [lz4, gzip, snappy, zstd, none] (default none)
compression.type=none

# The number of acknowledgments the producer requires the leader to have received before considering a request complete. Valid values: [all, -1, 0, 1] (default all)
# Less acks = less latency, but less durability
acks=-1

# Increase if there are a lot of partitions. The total bytes of memory the producer can use to buffer records waiting to be sent to the server. (default 33554432)
buffer.memory=33554432

# Duplication and Ordering
# set to 0 to preserve message order while request pipelining and max.in.flight.requests.per.connection=1, enable.idempotence=true
retries=2147483647

# Idempotent producers can handle duplicate messages and preserve message order even with request pipelining
enable.idempotence=false

# The maximum number of unacknowledged requests the client will send on a single connection before blocking.
max.in.flight.requests.per.connection=1

# An upper bound on the time to report success or failure after a call to send() returns. This limits the total time that a record will be delayed prior to sending, 
# the time to await acknowledgement from the broker (if expected), and the time allowed for retriable send failures.
delivery.timeout.ms=120000

# Consumer Properties

# The minimum amount of data the server should return for a fetch request.
# increase to ~1000000 to optimize throughput
# set to 1 to minimize latency
fetch.min.bytes=1

# The maximum amount of time the server will block before answering the fetch request if there isn’t sufficient data to immediately satisfy the requirement given by fetch.min.bytes.
fetch.max.wait.ms=500

# If true the consumer’s offset will be periodically committed in the background. Can set this to false and explicitly call commits in code with CommitSync() or CommitAsync()
enable.auto.commit=true

# Increase the session timeout to take into account potential network delays and to avoid soft failures.
session.timeout.ms=45000

# If you have have a poll() loop that spends much time processing messages:
    # 1. Increase the upper bound on the amount of time that a consumer can be idle before fetching more records
max.poll.interval.ms=300000

    # 2. Reduce the maximum size of batches the max.poll.records configuration parameter returns.
max.poll.records=500